---
description: 
globs: 
alwaysApply: true
---
General Monorepo Rules
Monorepo structure:

All apps are under /apps

All shared packages are under /packages

Use TypeScript throughout

Prefer functional components and hooks over classes

Use named exports for functions and components

Organize by feature where possible, not by type (feature folders)

Naming conventions:

PascalCase for components and screens

kebab-case for routes and files

camelCase for variables/functions

Use explicit types, prefer type over interface

Documentation:

Use TSDoc comments for all exported functions/components/types

No placeholders:

Do not generate incomplete code or leave TODOs

Frontend Web App
TanStack Start, Query, Router, Table
Use TanStack Query for all data fetching; prefer useInfiniteQuery for cursor-based pagination.

Define all route types centrally and export a .d.ts file for shared type safety across packages (avoid circular deps).

Use TanStack Table with stable data references and fully typed columns and rows.

Cursor-based pagination:

Always pass cursor as a query param to backend APIs

Use the returned nextCursor to fetch the next page

Do not use offset-based pagination for large/real-time datasets.

Tailwind CSS
Use a shared Tailwind config in /packages/ui and import into all apps.

Do not duplicate Tailwind configs; always extend from the base config.

tRPC
All API calls must use tRPC client hooks.

Use strict Zod validation on all procedure inputs/outputs.

Implement cursor pagination in tRPC procedures for lists.

Vite
Each app/package using Vite must have its own vite.config.ts extending shared config from /packages/config if present.

Shadcn
Import Shadcn UI components from the /packages/ui package.

Do not modify Shadcn source; extend via composition.

React-hotkeys-hook, dnd kit, React Dropzone, React pdf
Always wrap usage in fully typed custom hooks or components.

Place all drag-and-drop logic in /features/dnd or similar feature folders.

Frontend Mobile App
Expo, Tamagui
Use Expo managed workflow for all native features.

UI components must use Tamagui and be placed in /packages/ui for sharing.

Follow Tamaguiâ€™s compound component and shorthands guidelines.

expo-notifications:

Use expo-notifications for all push notifications; always set a notification handler.

expo-file-system:

All file handling must use expo-file-system API.

expo-sharing:

Use expo-sharing for all share actions; wrap in custom hooks for type safety.

tRPC
Use tRPC React Query hooks for all backend data.

Always validate inputs/outputs with Zod.

Frontend Desktop App
Vite, Tauri
Use Vite for frontend build and Tauri for native shell.

Access native APIs via @tauri-apps/api and local storage via tauri-plugin-store.

TanStack Query, Router, Table
Same rules as web app for data fetching, routing, and tables.

React-hotkeys-hook, Shadcn, Tailwindcss, dnd kit, React Dropzone, React pdf
Same usage and structure as in the web app.

Shared Frontend Libraries
tRPC, Datefns, Zustand, Zod
tRPC:

All client/server procedures must be fully typed and validated with Zod.

Datefns:

Use only via named imports; do not import all of date-fns.

Zustand:

Stores must be fully typed and use middleware for persistence/devtools as needed.

Use combine for state+actions patterns.

Always wrap store hooks with selectors for performance.

Zod:

All API and form validation must use Zod schemas.

Backend
Supabase
Use only @supabase/ssr for server and browser clients (never use auth-helpers-nextjs).

All database functions must use SECURITY INVOKER by default and set search_path = ''.

Prefer immutable or stable functions; use explicit input/output types.

Store all Supabase logic in /packages/backend/supabase.

Auth, Storage, Database
Auth must use Supabase Auth or Google OAuth.

All storage access via Supabase Storage API.

tRPC
All backend procedures must be validated with Zod.

Implement cursor-based pagination for list endpoints.

Analytics + Monitoring
Posthog, Openpanel
All analytics events must be typed and sent via a shared analytics utility in /packages/analytics.

Sync Engine
Powersync
Powersync logic must be isolated in /packages/sync.

All sync actions must be typed and side-effect free.

Dashboards
Recharts
All charts must be created as typed components in /packages/ui/src/charts.

Note Taking
Tiptap, mathjs, KaTeX
Tiptap editors must be wrapped in a custom component for consistent configuration.

All math rendering must use KaTeX; math parsing via mathjs.

Payment System
Polar
All payment logic must be isolated in /packages/payments.

All payment API calls must be fully typed.

Emails
Resend, React Email
All transactional emails must use Resend API.

All email templates must be React components, placed in /packages/emails/templates.

State Params Search Management
Nuqs
Use Nuqs for all URL state/search param management in web and desktop apps.

Cache & Rate Limiting
Upstash Redis
All cache and rate limiting logic must be in /packages/cache.

Do not access Redis directly from frontend.

Search
Meilisearch
All search logic must be in /packages/search.

All queries must be typed.

AI
AI sdk, Supermemory.ai, cohere, upstash vector, langchain
All AI integrations must be isolated in /packages/ai.

All prompt/response types must be defined and validated.

Background Tasks
Inngest
All background jobs must be defined in /packages/jobs.

Deployment & Domain Management
Vercel, EAS, Cloudflare, Tauri
All deployment configs must be in /apps/[app]/deployment or /packages/deployment.

Monorepo
Turborepo
All build, lint, and test scripts must be defined in turbo.json.

Use package-level overrides for custom build steps.

Shared config (tsconfig, eslint, tailwind, vite) must be in /packages/config.

Cursor-Specific Rules
Global rule:

Always respect the /apps and /packages structure; never create files at the repo root unless they are global configs.

When generating code, always check for existing feature folders and place new files/components accordingly.

For cross-app types (e.g., route types, shared schemas), generate .d.ts files in /packages/types and import from there.

Never generate duplicate configs; always extend from shared config packages.

When in doubt about file placement, prefer feature-based organization over type-based.

Tagging:

Tag all files with their feature and app/package for clarity.

Use project-level rules to describe the monorepo layout and main use cases.